name: Secret Scanning (TruffleHog)

on:
  pull_request:
  push:
    branches:
      - main

permissions:
  contents: read
  id-token: write
  pull-requests: write
  checks: write

jobs:
  trufflehog-scan:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Run TruffleHog (Diff Mode with JSON Output)
        id: trufflehog
        uses: trufflesecurity/trufflehog@main
        continue-on-error: true
        with:
          path: .
          base: "${{ github.event.repository.default_branch }}"
          head: HEAD
          extra_args: --json --jsonl --debug

      - name: Annotate PR with Inline Findings (Masked)
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        env:
          TRUFFLEHOG_JSON: ${{ steps.trufflehog.outputs.json }}
        with:
          script: |
            const raw = process.env.TRUFFLEHOG_JSON || '';
            if (!raw.trim()) {
              core.info('No TruffleHog JSON available; skipping annotations.');
              return;
            }
            const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
            const findings = lines.map(l => {
              try { return JSON.parse(l); } catch { return null; }
            }).filter(Boolean);

            function getPath(f) {
              return f.Path || (f.Source && f.Source.File) || f.File || '';
            }
            function getLine(f) {
              const candidates = [f.StartLine, f.Line, (f.Source && f.Source.Line)].filter(x => Number.isInteger(x) && x > 0);
              return candidates.length ? candidates[0] : 1;
            }
            function getDetector(f) {
              return f.DetectorName || f.Rule || f.Type || 'Secret';
            }
            function getMasked(f) {
              if (f.Redacted) return f.Redacted;
              if (f.Raw) {
                const raw = String(f.Raw);
                return raw.length > 6 ? raw.slice(0,3) + '***' + raw.slice(-3) : '***';
              }
              return '***';
            }

            const annotations = [];
            for (const f of findings) {
              const path = getPath(f);
              if (!path) continue;
              annotations.push({
                path,
                start_line: getLine(f),
                end_line: getLine(f),
                annotation_level: 'failure',
                title: `Secret Detected: ${getDetector(f)}`,
                message: `Potential secret found (masked): ${getMasked(f)}`
              });
              if (annotations.length >= 50) break;
            }

            const hasFindings = annotations.length > 0;
            const headSha = context.payload.pull_request ? context.payload.pull_request.head.sha : context.sha;

            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'TruffleHog Secret Scan',
              head_sha: headSha,
              status: 'completed',
              conclusion: hasFindings ? 'failure' : 'success',
              output: {
                title: 'TruffleHog Secret Scan',
                summary: hasFindings ? `ðŸš¨ ${annotations.length} secret(s) found` : 'âœ… No secrets detected',
                annotations
              }
            });

      - name: Fail build if secrets found
        if: steps.trufflehog.outcome == 'failure'
        run: exit 1
